
New patches:

[unrevert
anonymous**20081231051750] 
<
> {
hunk ./src/tourtre.c 38
 #include "ctAlloc.h"
 #include "ctContext.h"
 #include "ctNodeMap.h"
+#include "sglib.h"
 
 /* local functions */
 static
hunk ./src/tourtre.c 46
                         size_t end, 
                         int inc, 
                         ctComponentType type, 
-                        ctComponent ** comps, 
                         size_t * next, 
hunk ./src/tourtre.c 47
+                        ctComponent ***compList, /* ptr to array of ptrs, output*/
+                        size_t *numComps, /*output*/
                         ctContext * ctx );
 
 static
hunk ./src/tourtre.c 143
         
         ctx->joinRoot = 
             ct_sweep( 0,ctx->numVerts,+1,
-                CT_JOIN_COMPONENT, ctx->joinComps, ctx->nextJoin, ctx  );
+                CT_JOIN_COMPONENT, ctx->nextJoin, 
+                &ctx->joinComps, &ctx->numJoinComps, ctx  );
         ctx->splitRoot = 
             ct_sweep( ctx->numVerts-1,-1,-1, 
hunk ./src/tourtre.c 147
-                CT_SPLIT_COMPONENT, ctx->splitComps, ctx->nextSplit, ctx );
+                CT_SPLIT_COMPONENT, ctx->nextSplit, 
+                &ctx->splitComps, &ctx->numSplitComps, ctx );
         ct_augment( ctx );
         ret = ct_merge( ctx );
         
hunk ./src/tourtre.c 163
     size_t end, 
     int inc, 
     ctComponentType type,
-    ctComponent** comps, 
     size_t* next, 
hunk ./src/tourtre.c 164
+
+    ctComponent***compList,  /*output, ptr to array of ptrs*/
+    size_t *numComps, /*output*/
+
     ctContext* ctx )
 {
hunk ./src/tourtre.c 170
-    ct_checkContext(ctx);
-    {
-        size_t itr = 0, i = 0, n;
-        ctComponent * iComp;
-        int numExtrema = 0;
-        int numSaddles = 0;
-    
-        size_t * nbrs = (size_t*) calloc ( ctx->maxValence, sizeof(size_t) );
-    
-        for ( itr = start; itr != end; itr += inc ) {
-            size_t numNbrs;
-            int numNbrComps;
-            
-            i = ctx->totalOrder[itr];
+ct_checkContext(ctx);
+{
+    size_t itr = 0, i = 0, n;
+    ctComponent * iComp;
+    int numExtrema = 0;
+    int numSaddles = 0;
+    size_t * nbrs = calloc ( ctx->maxValence, sizeof(size_t) );
+    ctComponent **comps = calloc(ctx->numVerts,sizeof(ctComponent*));
+    memset(comps,0x0,ctx->numVerts*sizeof(ctComponent*));
+
+    for ( itr = start; itr != end; itr += inc ) {
+        size_t numNbrs;
+        int numNbrComps;
+        
+        i = ctx->totalOrder[itr];
+        
+        iComp = NULL;
+        numNbrs = (*(ctx->neighbors))(i,nbrs,ctx->data);
+        numNbrComps = 0;
+        for (n = 0; n < numNbrs; n++) {
+            size_t j = nbrs[n];
             
hunk ./src/tourtre.c 192
-            iComp = NULL;
-            numNbrs = (*(ctx->neighbors))(i,nbrs,ctx->data);
-            numNbrComps = 0;
-            for (n = 0; n < numNbrs; n++) {
-                size_t j = nbrs[n];
-                
-                if ( comps[j] ) {
-                    ctComponent * jComp = ctComponent_find( comps[j] );
+            if ( comps[j] ) {
+                ctComponent * jComp = ctComponent_find( comps[j] );
 
hunk ./src/tourtre.c 195
-                    if (iComp != jComp) {
-                        if (numNbrComps == 0) {
-    
-                            numNbrComps++;
-                            iComp = jComp;
-                            comps[i] = iComp;
-                            next[iComp->last] = i;
-    
-                        } else if (numNbrComps == 1) {
-                            
-                            
-                            /* create new component */
-                            ctComponent * newComp = ctComponent_new(type); 
-                            newComp->birth = i;
-                            ctComponent_addPred( newComp, iComp );
-                            ctComponent_addPred( newComp, jComp );
-    
-                            /* finish the two existing components */
-                            iComp->death = i;
-                            iComp->succ = newComp;
-                            ctComponent_union(iComp, newComp);
-    
-                            jComp->death = i;
-                            jComp->succ = newComp;
-                            ctComponent_union(jComp, newComp);
-    
-                            next[ jComp->last ] = i;
-    
-                            iComp = newComp;
-                            comps[i] = newComp;
-                            newComp->last = i;
-    
-                            numSaddles++;
-                            numNbrComps++;
-                            
-                        } else {
-    
-                            /*finish existing arc */
-                            jComp->death = i;
-                            jComp->succ = iComp;
-                            ctComponent_union(jComp,iComp);
-                            ctComponent_addPred(iComp,jComp);
-                            next[jComp->last] = i;
-                        }
+                if (iComp != jComp) {
+                    if (numNbrComps == 0) {
+                        numNbrComps++;
+                        iComp = jComp;
+                        comps[i] = iComp;
+                        next[iComp->last] = i;
+                    } else if (numNbrComps == 1) {
+                        
+                        /* create new component */
+                        ctComponent * newComp = ctComponent_new(type); 
+                        newComp->birth = i;
+                        ctComponent_addPred( newComp, iComp );
+                        ctComponent_addPred( newComp, jComp );
+
+                        /* finish the two existing components */
+                        iComp->death = i;
+                        iComp->succ = newComp;
+                        ctComponent_union(iComp, newComp);
+
+                        jComp->death = i;
+                        jComp->succ = newComp;
+                        ctComponent_union(jComp, newComp);
+
+                        next[ jComp->last ] = i;
+
+                        iComp = newComp;
+                        comps[i] = newComp;
+                        newComp->last = i;
+
+                        numSaddles++;
+                        numNbrComps++;
+                        
+                    } else {
+                        /*finish existing arc */
+                        jComp->death = i;
+                        jComp->succ = iComp;
+                        ctComponent_union(jComp,iComp);
+                        ctComponent_addPred(iComp,jComp);
+                        next[jComp->last] = i;
                     }
                 }
hunk ./src/tourtre.c 236
-            } /*  for each neighbor */
-    
-            if (numNbrComps == 0) {
-    
-                /* this was a local maxima. create a new component */
-                iComp = ctComponent_new(type);
-                iComp->birth = i;
-                comps[i] = iComp;
-                iComp->last = i;
-    
-                numExtrema++;
-
-            } else if (numNbrComps == 1) {
-    
-                /* this was a regular point. set last */
-                iComp->last = i;
             }
hunk ./src/tourtre.c 237
-    
-        } /* for each vertex */
-    
-        /* tie off end */
-        iComp = ctComponent_find( comps[i] );
-        iComp->death = i;
-    
-        /* terminate path */
-        next[i] = CT_NIL;
-    
-        free(nbrs);
-    
-        return iComp;
+        } /*  for each neighbor */
+
+        if (numNbrComps == 0) {
+            /* this was a local maxima. create a new component */
+            iComp = ctComponent_new(type);
+            iComp->birth = i;
+            comps[i] = iComp;
+            iComp->last = i;
+            numExtrema++;
+        } else if (numNbrComps == 1) {
+            /* this was a regular point. set last */
+            iComp->last = i;
+        }
+
+    } /* for each vertex */
+
+    /* tie off end */
+    iComp = ctComponent_find( comps[i] );
+    iComp->death = i;
+
+    /* terminate path */
+    next[i] = CT_NIL;
+
+    /* create comp list, sorted by index (NOT totalOrder) */
+    *numComps = numExtrema+numSaddles;
+    *compList = calloc(*numComps , sizeof(ctComponent*));
+    {   size_t i=0,n=0;
+        ctComponent **c=comps;
+        for (; i<ctx->numVerts; ++i,++c) 
+            if (i == (*c)->birth) (*compList)[++n]=*c;
     }
hunk ./src/tourtre.c 268
+
+    free(nbrs);
+    free(comps);
+
+    return iComp;
 }
hunk ./src/tourtre.c 274
-    
-static    
+}
+
+
+
+static
 void 
 ct_augment( ctContext * ctx )
 {
hunk ./src/tourtre.c 340
 }
 
 
+typedef 
+struct ComponentMap
+{
+    ctComponent **map;
+    size_t size;
+} ctComponentMap;
+
+
+#define CT_COMPONENT_COMPARE(X,Y) ((X)->birth - Y)
 
 static
hunk ./src/tourtre.c 351
-void 
+ComponentMap_find ( ComponentMap *m, size_t i )
+{
+    int found;
+    size_t ind;
+    SGLIB_ARRAY_BINARY_SEARCH(
+        ctComponent*, m->map, /*what*/
+        0,m->size, /*where*/
+        i, /*who*/
+        CT_COMPONENT_COMPARE, /*how*/
+        found,ind); /*output*/
+    assert(found);
+    return m->map[ind];
+}
+
+
+
+
+static
+ComponentMap 
 ct_queueLeaves( ctLeafQ *lq, ctComponent *c_, ctComponent **map )
 {
hunk ./src/tourtre.c 372
-  size_t stack_mem_size = 1024, stack_size=1;
-  ctComponent ** stack = (ctComponent**) malloc( stack_mem_size * sizeof(ctComponent*) );
-  stack[0] = c_;
-  while(stack_size) {
-    ctComponent *c = stack[--stack_size];  
-    map[c->birth] = c; /* the mapping will have changed in ct_augment */
-    if (ctComponent_isLeaf(c)) {
-      ctLeafQ_pushBack(lq,c);
-    } else {
-      ctComponent *pred = c->pred;
-      while (pred->nextPred) pred = pred->nextPred;
-      for (; pred != NULL; pred = pred->prevPred ) {
-        if (stack_size >= stack_mem_size-1) {
-          stack_mem_size *= 2;
-          { ctComponent **new_stack = 
-             (ctComponent**)realloc(stack,stack_mem_size*sizeof(ctComponent*));
-            stack = new_stack;
-          }
+    size_t stack_mem_size = 1024, stack_size=1;
+    ctComponent **stack = (ctComponent**) malloc( stack_mem_size * sizeof(ctComponent*) );
+    stack[0] = c_;
+
+    size_t list_mem_size=256, list_size=0;
+    ctComponent**list = malloc(list_mem_size*sizeof(ctComponent*));
+     
+
+    while(stack_size) {
+        ctComponent *c = stack[--stack_size];  
+        /* map[c->birth] = c; */ /* the mapping will have changed in ct_augment */
+
+        /* add to list */
+        list[list_size++] = c;
+        if (list_size == list_mem_size) {
+            list_mem_size *= 2;
+            list = realloc(list,list_mem_size*sizeof(ctComponent*));
+        }
+
+        if (ctComponent_isLeaf(c)) {
+            ctLeafQ_pushBack(lq,c);
+        } else {
+            ctComponent *pred = c->pred;
+            while (pred->nextPred) pred = pred->nextPred;
+            for (; pred != NULL; pred = pred->prevPred ) {
+                if (stack_size >= stack_mem_size-1) {
+                    stack_mem_size *= 2;
+                    stack = realloc(stack,stack_mem_size*sizeof(ctComponent*));
+                } 
+            }
+            stack[stack_size++] = pred; /* TODO: WTF IS THIS? */
         }
hunk ./src/tourtre.c 404
-        stack[stack_size++] = pred;
-      }
     }
hunk ./src/tourtre.c 405
-  }
-  free(stack);
+
+    free(stack);
+    list = realloc(list, list_size*sizeof(ctComponent*));
+    ComponentMap cm;
+    cm.map = list;
+    cm.size = list_size;
+    return cm;
+}
 } 
 
 
hunk ./src/tourtre.c 440
     size_t *nextJoin = ctx->nextJoin;
     size_t *nextSplit = ctx->nextSplit;
 
+    typedef ctComponent* (*CompLookup)(size_t,ctContext*);
+    CompLookup joinComp = lookupJoinComp; 
+    CompLookup splitComp = lookupSplitComp; 
     ctComponent **joinMap = ctx->joinComps;
     ctComponent **splitMap = ctx->splitComps;
     
hunk ./src/tourtre.c 449
     ctArc ** arcMap = ctx->arcMap;
     ctLeafQ * leafQ = ctLeafQ_new(0);
 
-    /* these are set to the above variables, depending of if the leaf is
-        * from the join or split tree */
-    ctComponent **map, **otherMap;
+    /* these are set to the above variables, depending of if the leaf is from
+     * the join or split tree */
+    ctComponent  **otherMap;
     size_t *next; 
 
     /* these phantom components take care of some special cases */
hunk ./src/tourtre.c 458
     ctComponent * plusInf = ctComponent_new(CT_JOIN_COMPONENT);
     ctComponent * minusInf = ctComponent_new(CT_SPLIT_COMPONENT);
 
+    
     memset(joinMap , 0, sizeof(ctComponent*)*ctx->numVerts);
     memset(splitMap, 0, sizeof(ctComponent*)*ctx->numVerts);
         
hunk ./src/tourtre.c 489
             /* which tree is this comp from? */
             if ( leaf->type == CT_JOIN_COMPONENT ) {
                 /* comp is join component */
-                map = joinMap;
                 otherMap = splitMap;
                 next = nextJoin;
                 lo = ctNodeMap_find(ctx->nodeMap,leaf->birth);
hunk ./src/tourtre.c 502
                     ctNodeMap_insert(&ctx->nodeMap,leaf->death,hi);
                 }
             } else { /* split component */
-                map = splitMap;
                 otherMap = joinMap;
                 next = nextSplit;
                 hi = ctNodeMap_find(ctx->nodeMap,leaf->birth);
hunk ./src/tourtre.c 567
     ctComponent_delete( minusInf );
     ctLeafQ_delete( leafQ );
 
-    free( ctx->joinComps );
-    free( ctx->splitComps );
-    ctx->joinComps = 0;
-    ctx->splitComps = 0;
-    
     return arc;
 }
 }
}

Context:

[using rbtree for ctNodeMap, instead of array
sedillard@gmail.com**20081231040735] 
[no idea
sedillard@gmail.com**20081231030819] 
[who knows
sedillard@ucdavis.edu**20081221204955] 
[finished tl example
sedillard@ucdavis.edu**20081221180110] 
[added trilinear example
sedillard@ucdavis.edu**20081221054104] 
[makefile changes
sedillard@ucdavis.edu**20081221052757] 
[added examples
sedillard@ucdavis.edu**20081219233318] 
[examples
sedillard@ucdavis.edu**20081219233206] 
[TAG v9
sedillard@ucdavis.edu**20081219232641] 
Patch bundle hash:
e3a4eef5b0b783737998c1351f762b43b01db086
